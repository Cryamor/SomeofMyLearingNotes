# OS

## 概述&体系结构

### 概述

OS：

#### OS目标

方便性、有效性

#### OS特征

- 并发性
- 共享性
- 异步性
- 虚拟性

#### 发展过程

简单批处理(慢)→多道程序批处理系统(缺少人机交互性)→**分时系统**→PC系统→并行系统→分布系统→**实时系统**

#### 并发&并行

- 并行：两个或多个事件在同一**时刻**同时发生
- 并发：两个或多个事件在同一**时间间隔**内同时发生(宏观中同时发生，微观中交替发生)

### 体系结构

#### I/O

##### 同步I/O

- I/O完成后控制权返回用户进程
- CPU空闲循环等待，直到下一个中断开始
- 任何时候最多一个I/O

##### 异步I/O

- 控制权无须等待I/O操作完成就可返回给用户进程

##### 可编程I/O

- 处理器提供I/O相关指令实现
- 处理器定期轮询I/O单元的状态，直到处理完毕
- 问题：占用CPU时间

##### 中断机制

- 让处理器从轮询任务中解放出来，使I/O和指令执行并行
- 当I/O处理单元准备好与设备交互时，通过物理信号通知处理器，即中断处理器

#### 存储层次

- CPU-缓存(Cache)-主存-辅存
- 考虑速度、价格、易失性

#### 保护

- 所有I/O指令都是特权指令
- 确保用户程序永远无法以monitor模式获得计算机的控制权。
- CPU保护：分时器；Load-timer是一种特权指令

#### 微内核结构

- 提供一些基本功能，如进程管理、存储器管理、进程间通信、低级I/O功能等
- 以微内核为OS核心，以客户/服务器为基础，采用面向对象程序设计特征
- 优点：便于扩充OS；便于移植；更好的安全性和可靠性
- 缺点：系统功能总开销增加导致系统性能下降

## 进程管理

### 进程

OS进行运行资源分配和调度的基本单位

#### 特性

- 并发性
- 独立性
- 动态性
- 交互性
- 异步性：各并发进程以独立的、不可预知的速度向前推进
- 结构性：进程（实体）= PCB+程序段+数据段

#### 状态

```
创建态 → 就绪态 ↔ 运行态 → 退出态

          ↑       ↓

          等待/阻塞态
```

就绪态→运行态：进程调度

运行态→阻塞态：进程主动，如I/O请求

阻塞态→就绪态：被动，如I/O完成

运行态→就绪态：时间片到，或被抢占

#### 进程通信

##### 共享存储区

- 共享数据结构：效率低，少量数据
- 共享存储区：高级，大量数据

##### 消息传递

- 最广泛
- 直接：消息缓冲
- 间接：信箱

##### 管道通信

- 共享文件方式，文件作为缓冲传输介质

#### 进程互斥

- 进程互斥：进程间因竞争共享公有资源而引起的间接制约关系
- 进程同步：完成同一个任务的伙伴进程间，因为在某些位置上需要协调它们的工作而相互等待、相互交换信息所产生的制约关系
- 进入区→临界区→退出区→剩余区


##### 原则

- 有空让进
- 无空等待
- 多中择一
- 有限等待
- 让权等待：进程不能进入临界区时释放处理机(CPU)，防止忙等待

##### 软件方法

###### 单标志法

- 进入区检查，turn==i 时允许 P~i~ 进入；退出区修改 turn=j
- 缺点：强制轮流进入临界区，资源利用不充分，违背了“有空让进”

###### 双标志先检查法

- 标志数组 flag[]，初值 False；进入区检查另一进程是否在临界区，不在则修改本进程标志；退出区修改本进程标志
- 先检查，后修改
- 优点：可连续使用，不需要交替进入
- 缺点：两个进程可能同时进入临界区

###### 双标志后检查法

- 先修改，后检查
- 优点：防止两个进程同时进入临界区
- 缺点：两个进程可能都无法进入临界区

###### Peterson算法

```c
bool flag[2];
int turn = 0;
/* P0 */
flag[0] = true;
turn = 1;
while (flag[1] && turn == 1);
critical section;
flag[0] = false;
remainer section;
/* P1 */
flag[1] = true;
turn = 0;
while (flag[0] && turn == 0);
critical section;
flag[1] = false;
remainer section;
```

- 先修改后检查，后修改者等待
- 是正确的算法

- 缺点：复杂；未满足“让权等待”，会发生忙等待

##### 硬件方法

###### Test-and-Set(TS)指令

```c
bool TestAndSet(bool *lock){
    bool old = *lock;
    *lock = true;
    return old;
}

while(TestandSet(&lock));
critical section;
lock = false;
remainer section;
```

- 不满足“让权等待”，会发生忙等待

###### Swap指令

```c
bool old = true;
while(old == true)
    Swap(&lock, &old);
critical section;
lock = false;
remainer section;
```

- 逻辑上同TS

###### 开关中断指令

- 进入临界区前执行“关中断”指令，离开后执行“开中断”指令

- 简单高效
- 不适用于多处理机，不适用于用户进程

###### 硬件方法优缺点

- 优点：简单易验证；适用于任意数目进程；支持多个临界区
- 缺点：不满足“让权等待”；存在“饥饿”；可能产生死锁

### 线程

#### TCB

包含: TID, PC, 寄存器, 堆栈...

#### 益处

同一进程内线程共享内存和文件, 相互通信无需调用内核, 线程数据可直接为其他线程所用

#### 实现方式

##### 用户级线程

优点：

- 切换不调用核心
- 调度算法基于应用程序特定
- 可运行在任何操作系统上

缺点：

- 进程阻塞将阻塞所有线程
- 进程内不同线程不能同时运行于不同机器上

##### 内核级线程

优点：

- 多处理器核心可同时调度同一进程的多个线程
- 阻塞在线程一级完成
- 核心例程是多线程的

缺点：

- 同一进程内线程切换调用内核，速度下降

##### 二者结合

- 一对一：线程管理都需要OS支持，开销大
- 多对一：开销小、阻塞问题
- 多对多：n用户→m内核(n≥m)，集二者所长

### 调度

#### 调度类型

- 高级(作业)调度: 外存→内存, 无→创建态→就绪态
- 中级(内存)调度: 外存→内存, 挂起态→就绪态；进程在内外存间的交换
- 低级(进程/微观)调度: 内存→CPU, 就绪态→运行态；毫秒级，频繁，高效

#### 调度方式

- 抢占/剥夺方式: 优先级原则, 时间片原则
- 非抢占/非剥夺方式: 简单, 开销小, 实时性差

#### 调度准则

- (最大)CPU利用率
- (最大)吞吐量: 总作业量 / 总时间
- (最小)周转时间: 作业完成时间 - 提交时间
- (最小)等待时间
- (最小)响应时间

#### 调度算法

##### FCFS (先来先服务)

- 非抢占式
- 对短作业不利
- 不会导致饥饿

##### SJR (最短作业优先)

- 非抢占式: 选择已经到达的运行时间最短的作业/进程
- 抢占式: SRTF

    e.g.

    | Process | Arrival Time | Burst Time |
    | ------- | ------------ | ---------- |
    | P1      | 0            | 7          |
    | P2      | 2            | 4          |
    | P3      | 4            | 1          |
    | P4      | 5            | 4          |

    | 0-2  | 2-4  | 4-5  | 5-7  | 7-11 | 11-16 |
    | ---- | ---- | ---- | ---- | ---- | ----- |
    | P1   | P2   | P3   | P2   | P4   | P1    |

- 平均等待时间最小
- 会导致饥饿

##### RR轮转调度

- 抢占式
- 周转时间大于SJF
- 响应时间小于SJF
- 不会导致饥饿

##### 优先级调度

- 抢占/非抢占
- 会导致饥饿(解决方法:老化)

##### 多级反馈队列调度

- 队列优先级高→低, 时间片小→大
- 抢占式, 被抢占的进程放回原队队尾

- 会导致饥饿(短进程源源不断到达)

### 信号量机制

#### 信号量S

- Semaphore，表示资源的实体，是一个与队列有关的整型变量

  ```c
  typedef struct {
    int value;         // 剩余资源数
    struct process *L; // 等待队列
  } semaphore;
  ```

- 只能通过初始化和P/V操作访问

- S>0：有S个资源可用；S=0：无资源可用；S<0：等待队列中进程数量

- 公用S实现进程互斥，初值为1

- 私用S实现进程同步，初值为0或正整数

#### P原语P(S)

- Proberen(测试)，申请分配一个单位的资源

  ```c
  void wait(semaphore S) {
      S.value--;
      if (S.value < 0)
          block(S.L); // 阻塞，加入等待队列
  }
  ```

#### V原语V(S)

- Verhogen(增加)，释放一个单位的资源

  ```c
  void signal(semaphore S) {
      S.value++;
      if (S.value <= 0)
          wakeup(S.L); // 唤醒头一个进程
  }
  ```

#### 应用

进程互斥：

```
semaphore mutex = 1;
...
P(mutex);
critical section;
V(mutex);
remainer section;
...
```

进程同步：

```c
semaphore S = 0;
/* code2需要在code4之前执行 */
P1(){
	code1;
	code2;
	V(S);
	code3;
}
P2(){
	P(S);
	code4;
	code5;
}
```

#### 典型问题

##### 生产者-消费者问题

- 共享缓冲区大小为N，初始为空；任何时刻只能有一个进程操作(互斥访问)

- ```c
  semaphore full = 0, empty = N, mutex = 1;
  Producer() {
      while(true) {
          // produce
          P(empty);
          P(mutex);
          push;
          V(mutex);
          V(full);
      }
  }
  Consumer() {
      while(true) {
          P(full);
          P(mutex);
          pop;
          V(mutex);
          V(empty);    
          // consume
      }
  }
  ```
  
- 互斥P要在同步P之后，否则导致死锁

##### 多生产者-多消费者问题

- 盘子只能装一个水果；爸爸放苹果，妈妈放桔子，女儿吃苹果，儿子吃桔子

- ```c
  semaphore apple = 0, orange = 0, plate = 1;
  semaphore mutex = 1; // plate=1时，可以不设置mutex
  Dad() {
      while(true) {
          // prepare apple
          P(plate);
          P(mutex);
          push apple;
          V(mutex);
          V(apple);
      }
  }
  Son {
      while(true) {
          P(orange);
          P(mutex);
          pop orange;
          V(mutex);
          V(plate);
          // eat orange
      }
  }
  Mom() {...}
  Daughter() {...}
  ```

##### 读者-写者问题

- 允许多个读者同时读，但不允许多个写者同时操作，或读者写者同时操作
- 读者优先：所有读者读完后再写

    ```c
    int readcount = 0;   // 记录当前有多少个读者在访问
    semaphore w = 1;     // 读写互斥
    semaphore mutex = 1; // 读者互斥修改readcount
    Writer() {
        while(true) {
            P(w);
            write;
            V(w);
        }
    }
    Reader() {
        while(true) {
            P(mutex);
            readcount++;
            if (readcount == 1)
                P(w);
            V(mutex);
    
            read;
    
            P(mutex);
            readcount--;
            if (readcount == 0)
                V(w);  // 最后一个读进程完成后解锁
            V(mutex);
        }
    }
    ```

- 写者优先：

    ```c
    int readcount = 0;   // 记录当前有多少个读者在访问
    int writecount = 0;  // 记录当前有多少个写者在访问
    semaphore w = 1;     // 读写互斥
    semaphore x = 1;     // 读者互斥修改readcount
    semaphore y = 1;     // 写者互斥修改writecount
    semaphore r = z = 1; // 写者优先
    Writer() {
        while(true) {
            P(y);
            writecount++;
            if (writecount == 1)
                P(r);
            V(y);
            
            P(w);
            write;
            V(w);
            
            P(y);
            writecount--;
            if (writecount == 0)
                V(r);
            V(y);        
        }
    }
    Reader() {
        while(true) {
            P(z);
            P(r);
            
            P(x)
            readcount++;
            if (readcount == 1)
                P(w);
            V(x);
    		
            V(r);
            V(z);
            
            read;
    
            P(x);
            readcount--;
            if (readcount == 0)
                V(w); 
            V(x);
        }
    }
    ```

##### 哲学家就餐问题

- 死锁：

    ```c
    semaphore chopstick[5] = {1, 1, 1, 1, 1};
    Pi(i) {
        while(true) {
            P(chopstick[i]);
            P(chopstick[(i + 1) % 5]);
            eat;
            V(chopstick[i]);
            V(chopstick[(i + 1) % 5]);
            think;
        }
    }
    ```

- 解决方案：
  1. 最多允许四人同时进餐
  2. 奇数号先拿左边筷子，偶数号先拿右边筷子

### 死锁

#### 条件

- 互斥
- 非抢占
- 持有并等待
- 循环等待

#### 处理

##### 死锁预防

破坏必要条件：

- 互斥：有些资源无法共享
- 非抢占：增加开销；导致饥饿
- 持有并等待：资源利用率低；可能导致饥饿
- 循环等待【顺序资源分配法(必须按照资源编号递增顺序申请资源)】：复杂；不方便增加新设备；实际顺序与编号顺序不一致，导致资源浪费

##### 死锁避免

- 要求每个进程事先声明所需资源的最大数量
- 保证永不进入不安全状态

##### 死锁检测&恢复

- 资源分配图：可完全简化(能消除所有边)则无死锁
- 恢复方法：终止进程法、资源抢占法
- 选择目标：进程优先级；已执行时间；完成需要时间；已使用资源；完成需要资源；需要终止的进程数量；交互式或批处理；……

## 内存管理

### 程序运行前工作

编译→链接→装入

#### 程序链接

- 静态链接
- 装入时动态链接
- 运行时动态链接

#### 程序装入

##### 绝对装入技术

- 固定地址再定位
- 优点：简单
- 缺点：过于依赖于硬件结构，不适于多道程序系统

##### 可重定位装入技术

###### 静态再定位

- 优点：易实现，无需硬件支持
- 缺点：程序再定位后不能移动，不利于内存的有效利用；程序在存储空间中只能连续分配

###### 动态重定位

- 装入时不修改逻辑地址，访问时转换，需要一个重定位寄存器
- 优点：程序在执行过程中可以移动，有利于内存充分利用；程序不必连续存放在内存中，可分散在内存若干个不同区域
- 缺点：需要附加硬件支持；软件算法复杂

### 内存管理思想

##### 目的

- 充分利用内存
- 方便用户使用
- 解决程序空间比实际内存空间大的问题
- 存储保护与安全
- 共享与通信
- 实现的性能和代价

##### 任务

- 存储分配和回收
- 存储共享
- 存储保护：上下限寄存器；重定位寄存器、界地址寄存器
- 存储器扩充
- 地址转换：逻辑地址→物理地址；三种装入

### 内存扩充技术

#### 覆盖技术

- 不会同时使用的程序共享一个覆盖区
- 必须由程序员声明覆盖结构，OS完成
- 缺点：对用户不透明，增加编程负担；外存装入覆盖文件，以时间延长换取空间节省

#### 交换技术

- 整体交换（进程交换）：以整个进程为单位
- 部分交换（页面/分段交换）：以分页、分段交换为单位；支持虚拟内存
- PCB仍在内存中
- 优点：增加并发程序数目；给用户提供适当的响应时间；不影响编写程序结构
- 缺点：换入换出控制增加处理机开销

#### 比较

| 覆盖                             | 交换                                   |
| -------------------------------- | -------------------------------------- |
| 主要用于早期OS                   | 广泛用于分时系统                       |
| 同一进程或作业内                 | 进程或作业之间                         |
| 只能覆盖那些与覆盖段无关的程序段 | 不要求用户给出程序段之间的逻辑覆盖结构 |

### 内存分配方式

#### 连续内存分配方式

##### 单一连续分配

- 分为系统区和用户区，内存中只能有一道用户程序

- 优点：简单；无外部碎片
- 缺点：只能用于单用户、单任务OS；有内部碎片；利用率低

##### 固定分区分配

- 划分为若干固定大小分区
- 优点：简单；支持多道程序；无外部碎片
- 缺点：内部碎片造成浪费；程序必须预先能够估计要占用多大的内存空间；分区总数固定，限制了并发执行的程序数目；

##### 动态分区分配

- 没有内碎片（分配给进程的内存区域没用上）
- 有外碎片（空闲分区太小无法利用）

##### 动态分区分配算法

###### 最先适配算法

- 找到符合要求的第一个
- 优点：简单；合并相邻分区容易
- 缺点：前面空闲区往往被分割的很小，满足分配要求的可能性较小，查找次数较多

###### 循环最先适配算法

- 从上次分配的分区起查找
- 优点：分配和释放的时间性能更好（最先适配的优点）
- 缺点：较大的空闲分区难以保留（最坏适配的缺点）

###### 最佳适配算法

- 寻找符合要求的最小分区
- 优点：较大的空闲分区可以被保留
- 缺点：空闲区是按大小而不是按地址顺序排列的，释放合并时重新排序，开销大；会留下很多难以利用的外部碎片

###### 最坏适配算法

- 取所有空闲区中最大的一块
- 优点：只需查找一次就可成功，分配算法很快
- 缺点：最后剩余分区会越来越小，无法运行大程序

#### 离散内存分配方式

##### 页式存储管理

- 内存块=页框=物理页面：内存按页划分为的大小相等的区域
- 页表：逻辑页号→内存块号
- 逻辑地址=页号P*页面大小+页内偏移量W
- 页表长度寄存器：检查页号P<页表长度M，否则越界
- 页表始址寄存器：页表项地址=起始地址F+页号P*页表项长度

- 快表（TLB）：存放最近访问页表项副本

- 两级页表
- 优点：无碎片
- 缺点：不利于程序共享、不利于动态链接

##### 段式存储管理

- 程序划分为程序段：段号+段内地址
- 段表：段号（由于段表项长度相等，所以可以隐含）+段首址+段长
- 段表长度/始址寄存器、快表……
- 优点：便于动态申请内存；便于共享；便于动态链接；管理和使用统一化
- 缺点：产生碎片

##### 段页式存储管理

- 进程空间：段式
- 内存空间：页式
- 段表：(段号)+页表长度+页号
- 页表：(页号)+内存块号

### 虚拟内存

#### 特征

- 不连续性：物理内存分配、虚拟地址空间使用不连续
- 部分交换
- 大空间

#### 虚拟页式机制

- 页表结构：页号+中断位+内存块号+外存地址+访问位+修改位
- 只在页面需要时，才将其载入内存；需要更少的输入输出；更小的内存；更快的响应；更多的用户

#### 页面置换算法

##### 先进先出算法（FIFO）

- 置换最早的页面
- 性能较差，抖动现象（刚换入就换出，或相反），Belady现象（物理块数增大，缺页次数不降反增，只会在FIFO算法中产生）

##### 最佳算法（OPT）

- 选择“未来不再使用的”或“在离当前最远位置上出现的”页面被置换
- 理想算法，无法实现

##### 最近最久未使用算法（LRU）

- 逆向扫描最后一个出现的页号淘汰

- 性能最接近OPT
- 开销大，复杂

##### 最不常用算法（LFU）

- 选择到当前时间为止被访问次数最少的页面被置换（每页设置访问计数器，缺页时全部清零）

##### 简单轮转算法（clock）

- 也称最近未使用算法(NRU)，是LRU和FIFO的折中
- 每页标志位（use），若该页被访问则置1
- 置换时，从当前指针位置开始先后检查各页，寻找use=0的页面作为被置换页，并将指针经过的页修改为user=0 ，最后指针停留在被置换页的下一个页。

#### 策略

##### 调入策略

###### 请求调页

- 优点：容易实现
- 缺点：对外存I/O次数多，开销较大

###### 预调页

- 一次调入该页及相邻的几个页；常用于程序装入时的调页
- 优点：提高调页的I/O效率
- 缺点：基于预测，若调入的页在以后很少被访问，则效率低。

##### 调入来源

外存分为

###### 交换区

- 读写速度快

- 进程装入时，将全部页面复制到交换区，以后总是从交换区调入
- 调入速度快，要求交换区空间较大

###### 文件区

- 读写速度慢

- 未被修改的页面，直接从文件区读入，被置换时不需调出
- 已被修改的页面，被置换时需调出到交换区，以后从交换区调入

##### 常驻集和工作集策略

###### 常驻集

- 虚拟页式管理中给进程分配的物理页面数目
- 固定分配
- 可变分配

###### 工作集

- 进程实际访问的页面集合
- 总是让常驻集包含工作集
- 困难：工作集的过去变化未必能够预示工作集的将来大小或组成页面的变化；记录工作集变化要求开销太大；对工作集窗口大小D的取值难以优化，而且通常该值是不断变化的

##### 置换策略

- 局部置换：容易进行性能分析
- 全局置换：更为简单，容易实现，运行开销小
- 固定分配+局部置换：运行前分配物理块，缺页时只能置换自己进程某一页
- 可变分配+局部置换：只要缺页就分配新物理块
- 可变分配+全局置换：频繁缺页者多分配

##### 负载控制策略

- 基于工作集：常驻集足够大的进程才能运行，从而实现对负载的自动和动态控制

- L=S判据：让缺页平均间隔时间等于对每次缺页的处理时间（即缺页率保持在最佳水平），这时CPU利用率达到最大
- 基于轮转置换算法：当轮转计数少于一定阈值时，表明缺页较少或存在足够的空闲页面；当轮转计数大于阈值时，隐含系统的进程并发水平过高，需降低系统负载

## 文件管理

### 文件结构

文件：一组带标识的、在逻辑上有完整意义的信息项的序列，是信息存储在磁盘或其他外部介质上的单元

文件系统：OS中统一管理信息资源的一种软件，管理文件的存储、检索、更新，提供安全可靠的共享和保护手段，并且方便用户使用

目标：

- 统一管理文件的存储空间，实施存储空间的分配与回收
- 实现文件的按名存取
- 实现文件信息的共享，并提供文件保护和保密措施
- 向用户提供方便使用的接口
- 提供与I/O的统一接口
- ……

#### 逻辑结构

- 无结构文件(流式文件)：有逻辑意义的、无结构的一串字符的集合(如txt)，提供很大的灵活性
- 有结构文件(记录式文件)

#### 物理结构

##### 顺序结构

- 文件信息存放在若干连续的物理块中，文件目录：始址-块数
- 优点：简单；支持顺序和随机存取；顺序存取速度快；磁盘寻道次数和时间少
- 缺点：文件不能动态增长；预留空间浪费；不利于文件插入和删除；外碎片问题

##### 链接结构

- 文件目录：始址-末址
- 优点：提高了磁盘空间利用率,不存在外部碎片问题；利于文件插入和删除；利于文件动态扩充
- 存取速度慢，不适于随机存取；可靠性问题(指针出错)；更多的寻道次数和时间；链接指针占用空间

##### 索引结构

- 不连续物理块，建立索引表
- 优点：既能顺序存取,又能随机存取；满足文件动态增长、插入、删除的要求；充分利用外存
- 缺点：较多的寻道次数和寻道时间；索引表自身开销(时间&空间)
- 多级索引

### 文件目录

#### FCB

- 文件名、地址、长度、更新时间……
- FCB→文件目录

#### 目录结构

- FCB的有序集合，以文件形式保存在外存
- 一级目录结构：简单；无法重名
- 二级目录结构
- 树形(多级)目录结构
- 其他：哈希表、B+树
- 减少了访问硬盘的次数，提高了检索速度

### 空闲空间管理

数据结构：空闲块表、空闲块链表……

#### 位示图

- 每个物理块对应一位(0/1)
- 描述能力强，适合各种物理结构

### 文件系统实现

#### 文件执行

##### Create()

建立FCB和分配存储空间

1. 检查参数的合法性
2. 检查同一目录下有无重名文件
3. 在目录中有无空闲位置
4. 填写目录项内容
5. 返回(文件描述)

##### Open()

先打开，即把FCB送到内存

1. 根据文件路径名查目录，找到FCB主部
2. 根据打开方式、共享说明和用户身份检查访问合法性
3. 根据文件号查系统打开文件表，看文件是否已被打开；是→共享计数加1，否则→将外存中的FCB主部等信息填入系统打开文件表空表项，共享计数置为1

### 磁盘管理

#### 磁盘结构

- 外存：容量大，断电后可保存信息，速度慢，成本低；驱动部分+存储介质
- 磁带：永久保存大容量数据；顺序存取，慢
- 光盘：容量大，速度快，价格便宜；一般不可写
- 磁盘：直接(随机)存取；物理地址：磁头(盘面)号+磁道(柱面)号+扇区号
- 一次访盘时间=寻道+旋转延迟+数据传输

#### 磁盘调度

调度目的：公平性(一个I/O请求在有限时间内满足)、高效性(减少机械运动时间浪费)

##### 先来先服务(FCFS)

- 按访问请求到达的先后次序服务
- 优点：简单、公平
- 缺点：效率低，磁头反复移动对机械也不利

##### 最短寻道时间优先(SSTF)

- 优先选择距当前磁头最近的访问请求进行服务，主要考虑寻道优先
- 优点：改善了磁盘平均服务时间
- 缺点：造成某些访问请求长期等待得不到服务

##### 扫描算法(电梯算法，SCAN)

- 磁臂从一端向另一端移动并处理路上的请求，到达时反向
- 优点：防止饥饿
- 缺点：刚越过时加入新请求，需要等磁头到达另一端并反向返回才能处理

##### 单向扫描算法/循环扫描算法(C-SCAN)

- 当磁头到另一端时，返回开始

#### 容错技术

廉价磁盘冗余阵列RAID：

- 并行交叉存取
- 可靠性高
- I/O速度快
- 性价比高